-- Generated by Haxe 4.3.3
local _hx_hidden = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true, __fields__=true, __name__=true}
local cbor = require("cbor.cbor")
local inspect = require("inspect")

_hx_array_mt = {
    __newindex = function(t,k,v)
        local len = t.length
        t.length =  k >= len and (k + 1) or len
        rawset(t,k,v)
    end
}

function _hx_is_array(o)
    return type(o) == "table"
        and o.__enum__ == nil
        and getmetatable(o) == _hx_array_mt
end



function _hx_tab_array(tab, length)
    tab.length = length
    return setmetatable(tab, _hx_array_mt)
end



function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

function _hx_print_enum(o, depth)
    if o.length == 2 then
        return o[0]
    else
        local str = o[0] .. "("
        for i = 2, (o.length-1) do
            if i ~= 2 then
                str = str .. "," .. _hx_tostring(o[i], depth+1)
            else
                str = str .. _hx_tostring(o[i], depth+1)
            end
        end
        return str .. ")"
    end
end

function _hx_tostring(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = _G.type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == _G.math.POSITIVE_INFINITY then return "Infinity"
        elseif obj == _G.math.NEGATIVE_INFINITY then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return _G.tostring(obj)
        end
    elseif tstr == "boolean" then return _G.tostring(obj)
    elseif tstr == "userdata" then
        local mt = _G.getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return _G.tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                local str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            local buffer = {}
            local ref = obj
            if obj.__fields__ ~= nil then
                ref = obj.__fields__
            end
            for k,v in pairs(ref) do
                if _hx_hidden[k] == nil then
                    _G.table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end

            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        _G.error("Unknown Lua type", 0)
        return ""
    end
end

local function _hx_obj_newindex(t,k,v)
    t.__fields__[k] = true
    rawset(t,k,v)
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_obj_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_obj_newindex, __index=prototype, __tostring=_hx_tostring})
end

function _hx_field_arr(obj)
    local res = {}
    local idx = 0
    if obj.__fields__ ~= nil then
        obj = obj.__fields__
    end
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            res[idx] = k
            idx = idx + 1
        end
    end
    return _hx_tab_array(res, idx)
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

local Array = _hx_e()
__haxe_IMap = _hx_e()
local IOrderedMap = _hx_e()
local FunctionDef = _hx_e()
local TableElem = _hx_e()
local Expr = _hx_e()
local Stmt = _hx_e()
Parser = _G.require("ParseLua")
local NameGenerator = _hx_e()
local PullFunction = _hx_e()
local InsertGotos = _hx_e()
local LuaParse = _hx_e()
local Math = _hx_e()
local OrderedStringMapImpl = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringTools = _hx_e()
__haxe_Exception = _hx_e()
__haxe_NativeStackTrace = _hx_e()
__haxe_ValueException = _hx_e()
__haxe_ds_Option = _hx_e()
__haxe_ds_StringMap = _hx_e()
__haxe_exceptions_PosException = _hx_e()
__haxe_exceptions_NotImplementedException = _hx_e()
__haxe_iterators_ArrayIterator = _hx_e()
__haxe_iterators_ArrayKeyValueIterator = _hx_e()
__haxe_iterators_MapKeyValueIterator = _hx_e()
__lua_Boot = _hx_e()
__lua_UserData = _hx_e()
__lua_Thread = _hx_e()
__sys_io_File = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
Array.__name__ = true
Array.prototype = _hx_e();
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g = 0;
  while (_g < a.length) do _hx_do_first_1 = false;
    
    local i = a[_g];
    _g = _g + 1;
    ret:push(i);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _g_current = 0;
  local _g_array = self;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local i = _g_array[_g_current - 1];
    _G.table.insert(tbl, Std.string(i));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do _hx_do_first_1 = false;
    
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do _hx_do_first_1 = false;
    
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do _hx_do_first_2 = false;
      
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g = pos + len;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self[i] = self[i + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g = i;
      local _g1 = self.length - 1;
      while (_g < _g1) do _hx_do_first_2 = false;
        
        _g = _g + 1;
        local j = _g - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.contains = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do _hx_do_first_1 = false;
    
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self) end
end
Array.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_ArrayKeyValueIterator.new(self) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

__haxe_IMap.new = {}
__haxe_IMap.__name__ = true
__haxe_IMap.prototype = _hx_e();

__haxe_IMap.prototype.__class__ =  __haxe_IMap

IOrderedMap.new = {}
IOrderedMap.__name__ = true
IOrderedMap.__interfaces__ = {__haxe_IMap}
IOrderedMap.prototype = _hx_e();

IOrderedMap.prototype.__class__ =  IOrderedMap


local encodemt
local decoders

local encodemt_func = function(enum)
  return cbor.encode(cbor.tagged(1234, enum.__packed))
end
local encode_array = function(array)
  return cbor.encode(cbor.tagged(2137, array), {
    [encodemt] = encodemt_func
  })
end

encodemt = {
    __index = function(t, tk)
        local packed = rawget(t, "__packed")
        return cbor.decode(packed, decoders)[tk]

      --   local array_dec = cbor.type_decoders[4]
      --   local map_dec = cbor.type_decoders[5]
      --   cbor.type_decoders[4] = function(fh, mintyp, opts)
      --     if mintyp == 31 then
      --       local i = 1;
      --       local v = cbor.decode_file(fh, opts);
      --       if i == tk then
      --         return v
      --       end
      --       while v ~= cbor.BREAK do
      --         i = i + 1;
      --         v = cbor.decode_file(fh, opts);
      --         if i == tk then
      --           return v
      --         end
      --       end
      --     else
      --       local len = cbor.read_length(fh, mintyp);
      --       for i = 1, len do
      --         local v = cbor.decode_file(fh, opts);
      --         if i == tk then
      --           return v
      --         end
      --       end
      --     end
      --   end
      -- cbor.type_decoders[5] = function(fh, mintyp, opts)
      --   if mintyp == 31 then
      --     local i = 1;
      --     local k = cbor.decode_file(fh, opts);
      --     while k ~= cbor.BREAK do
      --       local v = cbor.decode_file(fh, opts)
      --       if k == tk then
      --         return v
      --       end
      --       i =  i + 1;
      --       k = cbor.decode_file(fh, opts);
      --     end
      --   else
      --     local len = cbor.read_length(fh, mintyp);
      --     for _ = 1, len do
      --       local k = cbor.decode_file(fh, opts);
      --       local v = cbor.decode_file(fh, opts);
      --       if k == tk then
      --         return v
      --       end
      --     end
      --   end
      -- end


      -- local v2 = cbor.decode(rawget(t, "__packed"), decoders)

      -- cbor.type_decoders[4] = array_dec
      -- cbor.type_decoders[5] = map_dec
    end,
    __newindex = function(t, k, v)
        error("can't set new values on encodable object")
    end
}

local opts = {
  [_hx_array_mt] = encode_array,
  [encodemt] = encodemt_func
}

decoders = {
  [1234] = function(v)
    return setmetatable({__packed = v}, encodemt)
  end,
  [2137] = function(v)
    return setmetatable(v, _hx_array_mt)
  end
}

_hx_tab_array2 = function(tbl, length)
    tbl.length = length
    local encoded = cbor.encode(tbl, opts)
    return setmetatable({__packed=encoded}, encodemt)
end

-- UNCOMMENT FOR DEFAULT BEHAVIOR:
-- _hx_tab_array2 = _hx_tab_array


_hxClasses["FunctionDef"] = { __ename__ = true, __constructs__ = _hx_tab_array2({[0]="FuncDef"},1)}
FunctionDef = _hxClasses["FunctionDef"];
FunctionDef.FuncDef = function(args,vararg,body) local _x = _hx_tab_array2({[0]="FuncDef",0,args,vararg,body}, 5); return _x; end 
_hxClasses["TableElem"] = { __ename__ = true, __constructs__ = _hx_tab_array2({[0]="Key","KeyString","Value"},3)}
TableElem = _hxClasses["TableElem"];
TableElem.Key = function(key,value) local _x = _hx_tab_array2({[0]="Key",0,key,value}, 4); return _x; end 
TableElem.KeyString = function(key,value) local _x = _hx_tab_array2({[0]="KeyString",1,key,value}, 4); return _x; end 
TableElem.Value = function(value) local _x = _hx_tab_array2({[0]="Value",2,value}, 3); return _x; end 
_hxClasses["Expr"] = { __ename__ = true, __constructs__ = _hx_tab_array2({[0]="FunctionExpr","VarExpr","MemberExpr","IndexExpr","CallExpr","NumberExpr","StringExpr","NilExpr","BooleanExpr","DotsExpr","ConstructorExpr","UnopExpr","BinopExpr"},13)}
Expr = _hxClasses["Expr"];
Expr.FunctionExpr = function(f) local _x = _hx_tab_array2({[0]="FunctionExpr",0,f}, 3); return _x; end 
Expr.VarExpr = function(name) local _x = _hx_tab_array2({[0]="VarExpr",1,name}, 3); return _x; end 
Expr.MemberExpr = function(base,indexer,ident) local _x = _hx_tab_array2({[0]="MemberExpr",2,base,indexer,ident}, 5); return _x; end 
Expr.IndexExpr = function(base,index) local _x = _hx_tab_array2({[0]="IndexExpr",3,base,index}, 4); return _x; end 
Expr.CallExpr = function(base,args) local _x = _hx_tab_array2({[0]="CallExpr",4,base,args}, 4); return _x; end 
Expr.NumberExpr = function(value) local _x = _hx_tab_array2({[0]="NumberExpr",5,value}, 3); return _x; end 
Expr.StringExpr = function(value) local _x = _hx_tab_array2({[0]="StringExpr",6,value}, 3); return _x; end 
Expr.NilExpr = _hx_tab_array2({[0]="NilExpr",7},2)

Expr.BooleanExpr = function(value) local _x = _hx_tab_array2({[0]="BooleanExpr",8,value}, 3); return _x; end 
Expr.DotsExpr = _hx_tab_array2({[0]="DotsExpr",9},2)

Expr.ConstructorExpr = function(entryList) local _x = _hx_tab_array2({[0]="ConstructorExpr",10,entryList}, 3); return _x; end 
Expr.UnopExpr = function(rhs,op,opPrec) local _x = _hx_tab_array2({[0]="UnopExpr",11,rhs,op,opPrec}, 5); return _x; end 
Expr.BinopExpr = function(lhs,op,opPrec,rhs) local _x = _hx_tab_array2({[0]="BinopExpr",12,lhs,op,opPrec,rhs}, 6); return _x; end 
_hxClasses["Stmt"] = { __ename__ = true, __constructs__ = _hx_tab_array2({[0]="IfStatement","WhileStatement","DoStatement","NumericForStatement","GenericForStatement","RepeatStatement","FunctionStatement","LocalStatement","LabelStatement","ReturnStatement","BreakStatement","GotoStatement","AssignmentStatement","CallStatement"},14)}
Stmt = _hxClasses["Stmt"];
Stmt.IfStatement = function(cond,thenBody,elseBody) local _x = _hx_tab_array2({[0]="IfStatement",0,cond,thenBody,elseBody}, 5); return _x; end 
Stmt.WhileStatement = function(cond,body) local _x = _hx_tab_array2({[0]="WhileStatement",1,cond,body}, 4); return _x; end 
Stmt.DoStatement = function(body) local _x = _hx_tab_array2({[0]="DoStatement",2,body}, 3); return _x; end 
Stmt.NumericForStatement = function(variable,start,finish,step,body) local _x = _hx_tab_array2({[0]="NumericForStatement",3,variable,start,finish,step,body}, 7); return _x; end 
Stmt.GenericForStatement = function(varList,generators,body) local _x = _hx_tab_array2({[0]="GenericForStatement",4,varList,generators,body}, 5); return _x; end 
Stmt.RepeatStatement = function(cond,body) local _x = _hx_tab_array2({[0]="RepeatStatement",5,cond,body}, 4); return _x; end 
Stmt.FunctionStatement = function(name,isLocal,f) local _x = _hx_tab_array2({[0]="FunctionStatement",6,name,isLocal,f}, 5); return _x; end 
Stmt.LocalStatement = function(names,initExprs) local _x = _hx_tab_array2({[0]="LocalStatement",7,names,initExprs}, 4); return _x; end 
Stmt.LabelStatement = function(label) local _x = _hx_tab_array2({[0]="LabelStatement",8,label}, 3); return _x; end 
Stmt.ReturnStatement = function(args) local _x = _hx_tab_array2({[0]="ReturnStatement",9,args}, 3); return _x; end 
Stmt.BreakStatement = _hx_tab_array2({[0]="BreakStatement",10},2)

Stmt.GotoStatement = function(label) local _x = _hx_tab_array2({[0]="GotoStatement",11,label}, 3); return _x; end 
Stmt.AssignmentStatement = function(lhs,rhs) local _x = _hx_tab_array2({[0]="AssignmentStatement",12,lhs,rhs}, 4); return _x; end 
Stmt.CallStatement = function(base,args) local _x = _hx_tab_array2({[0]="CallStatement",13,base,args}, 4); return _x; end 


NameGenerator.new = function(prefix) 
  local self = _hx_new(NameGenerator.prototype)
  NameGenerator.super(self,prefix)
  return self
end
NameGenerator.super = function(self,prefix) 
  self.state = 0;
  self.prefix = prefix;
end
NameGenerator.__name__ = true
NameGenerator.prototype = _hx_e();
NameGenerator.prototype.next = function(self) 
  local name = Std.string(Std.string("") .. Std.string(self.prefix)) .. Std.string(self.state);
  self.state = self.state + 1;
  do return name end
end

NameGenerator.prototype.__class__ =  NameGenerator

PullFunction.new = function(freshVar) 
  local self = _hx_new(PullFunction.prototype)
  PullFunction.super(self,freshVar)
  return self
end
PullFunction.super = function(self,freshVar) 
  self.freshVar = freshVar;
end
PullFunction.__name__ = true
PullFunction.prototype = _hx_e();
PullFunction.prototype.pullFunc = function(self,f,pulled) 
  local args = f[2];
  local vararg = f[3];
  local body = f[4];

  -- print(inspect(f))
  do return FunctionDef.FuncDef(args, vararg, self:pullStmts(body)) end
end
PullFunction.prototype.pullTableElem = function(self,elem,pulled) 
  local _g = self;
  local pulled = pulled;
  local pullExpr = function(expr) 
    do return _g:pullExpr(expr, pulled) end;
  end;
  local tmp = elem[1];
  if (tmp) == 0 then 
    local key = elem[2];
    local value = elem[3];
    do return TableElem.Key(pullExpr(key), pullExpr(value)) end;
  elseif (tmp) == 1 then 
    local key = elem[2];
    local value = elem[3];
    do return TableElem.KeyString(key, pullExpr(value)) end;
  elseif (tmp) == 2 then 
    local value = elem[2];
    do return TableElem.Value(pullExpr(value)) end; end;
end
PullFunction.prototype.pullStmts = function(self,stmts) 
  local newStmts = Array.new();
  local _g = 0;
  while (_g < stmts.length) do _hx_do_first_1 = false;
    
    local stmt = stmts[_g];
    _g = _g + 1;
    local pulled = OrderedStringMapImpl.new();
    local newStmt = self:pullStmt(stmt, pulled);
    local _g = pulled:keyValueIterator();
    while (_g:hasNext()) do _hx_do_first_2 = false;
      
      local _g = _g:next();
      local name = _g.key;
      local expr = _g.value;
      newStmts:push(Stmt.LocalStatement(_hx_tab_array({[0]=name}, 1), _hx_tab_array({[0]=expr}, 1)));
    end;
    newStmts:push(newStmt);
  end;
  do return newStmts end
end
PullFunction.prototype.pullStmt = function(self,stmt,pulled) 
  local _g = self;
  local pulled1 = pulled;
  local pullExpr = function(expr) 
    do return _g:pullExpr(expr, pulled1) end;
  end;
  local _g = self;
  local pulled = pulled;
  local pullFunc = function(f) 
    do return _g:pullFunc(f, pulled) end;
  end;
  local tmp = stmt[1];
  if (tmp) == 0 then 
    local cond = stmt[2];
    local thenBody = stmt[3];
    local elseBody = stmt[4];
    do return Stmt.IfStatement(pullExpr(cond), self:pullStmts(thenBody), self:pullStmts(elseBody)) end;
  elseif (tmp) == 1 then 
    local cond = stmt[2];
    local body = stmt[3];
    do return Stmt.WhileStatement(pullExpr(cond), self:pullStmts(body)) end;
  elseif (tmp) == 2 then 
    local body = stmt[2];
    do return Stmt.DoStatement(self:pullStmts(body)) end;
  elseif (tmp) == 3 then 
    local _g = stmt[2];
    local _g1 = stmt[3];
    local _g2 = stmt[4];
    local _g3 = stmt[5];
    local _g4 = stmt[6];
    local tmp = _g3[1];
    if (tmp) == 0 then 
      local step = _g3[2];
      local finish = _g2;
      local start = _g1;
      local variable = _g;
      local body = _g4;
      do return Stmt.NumericForStatement(variable, pullExpr(start), pullExpr(finish), __haxe_ds_Option.Some(pullExpr(step)), self:pullStmts(body)) end;
    elseif (tmp) == 1 then 
      local finish = _g2;
      local start = _g1;
      local variable = _g;
      local body = _g4;
      do return Stmt.NumericForStatement(variable, pullExpr(start), pullExpr(finish), __haxe_ds_Option.None, self:pullStmts(body)) end; end;
  elseif (tmp) == 4 then 
    local varList = stmt[2];
    local generators = stmt[3];
    local body = stmt[4];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = generators;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(pullExpr(i));
    end;
    do return Stmt.GenericForStatement(varList, _g, self:pullStmts(body)) end;
  elseif (tmp) == 5 then 
    local cond = stmt[2];
    local body = stmt[3];
    do return Stmt.RepeatStatement(pullExpr(cond), self:pullStmts(body)) end;
  elseif (tmp) == 6 then 
    local name = stmt[2];
    local isLocal = stmt[3];
    local f = stmt[4];
    -- print(inspect(stmt))
    do return Stmt.FunctionStatement(pullExpr(name), isLocal, pullFunc(f)) end;
  elseif (tmp) == 7 then 
    local names = stmt[2];
    local initExprs = stmt[3];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = initExprs;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(pullExpr(i));
    end;
    do return Stmt.LocalStatement(names, _g) end;
  elseif (tmp) == 8 then 
    local _g = stmt[2];
    do return stmt end;
  elseif (tmp) == 9 then 
    local args = stmt[2];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = args;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(pullExpr(i));
    end;
    do return Stmt.ReturnStatement(_g) end;
  elseif (tmp) == 10 then 
    do return stmt end;
  elseif (tmp) == 11 then 
    local _g = stmt[2];
    do return stmt end;
  elseif (tmp) == 12 then 
    local lhs = stmt[2];
    local rhs = stmt[3];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = lhs;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(pullExpr(i));
    end;
    local tmp = _g;
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = rhs;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(pullExpr(i));
    end;
    do return Stmt.AssignmentStatement(tmp, _g) end;
  elseif (tmp) == 13 then 
    local base = stmt[2];
    local args = stmt[3];
    local tmp = pullExpr(base);
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = args;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(pullExpr(i));
    end;
    do return Stmt.CallStatement(tmp, _g) end; end;
end
PullFunction.prototype.pullExpr = function(self,expr,pulled) 
  local _g = self;
  local pulled1 = pulled;
  local pullExpr = function(expr) 
    do return _g:pullExpr(expr, pulled1) end;
  end;
  local _g = self;
  local pulled1 = pulled;
  local pullFunc = function(f) 
    do return _g:pullFunc(f, pulled1) end;
  end;
  local _g = self;
  local pulled1 = pulled;
  local pullTableElem = function(elem) 
    do return _g:pullTableElem(elem, pulled1) end;
  end;
  local converted;
  local converted1 = expr[1];
  if (converted1) == 0 then 
    local f = expr[2];
    converted = Expr.FunctionExpr(pullFunc(f));
  elseif (converted1) == 1 then 
    local _g = expr[2];
    converted = expr;
  elseif (converted1) == 2 then 
    local base = expr[2];
    local indexer = expr[3];
    local ident = expr[4];
    converted = Expr.MemberExpr(pullExpr(base), indexer, ident);
  elseif (converted1) == 3 then 
    local base = expr[2];
    local index = expr[3];
    converted = Expr.IndexExpr(pullExpr(base), pullExpr(index));
  elseif (converted1) == 4 then 
    local base = expr[2];
    local args = expr[3];
    local converted1 = pullExpr(base);
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = args;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(pullExpr(i));
    end;
    converted = Expr.CallExpr(converted1, _g);
  elseif (converted1) == 5 then 
    local _g = expr[2];
    converted = expr;
  elseif (converted1) == 6 then 
    local _g = expr[2];
    converted = expr;
  elseif (converted1) == 8 then 
    local _g = expr[2];
    converted = expr;
  elseif (converted1) == 7 or (converted1) == 9 then 
    converted = expr;
  elseif (converted1) == 10 then 
    local entryList = expr[2];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = entryList;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(pullTableElem(i));
    end;
    converted = Expr.ConstructorExpr(_g);
  elseif (converted1) == 11 then 
    local rhs = expr[2];
    local op = expr[3];
    local opPrec = expr[4];
    converted = Expr.UnopExpr(pullExpr(rhs), op, opPrec);
  elseif (converted1) == 12 then 
    local lhs = expr[2];
    local op = expr[3];
    local opPrec = expr[4];
    local rhs = expr[5];
    converted = Expr.BinopExpr(pullExpr(lhs), op, opPrec, pullExpr(rhs)); end;
  if (expr[1] == 4) then 
    local _g = expr[2];
    local _g = expr[3];
    local name = self.freshVar:next();
    pulled:set(name, converted);
    do return Expr.VarExpr(name) end;
  else
    do return converted end;
  end;
end

PullFunction.prototype.__class__ =  PullFunction

InsertGotos.new = function(freshVar,freshLabel) 
  local self = _hx_new(InsertGotos.prototype)
  InsertGotos.super(self,freshVar,freshLabel)
  return self
end
InsertGotos.super = function(self,freshVar,freshLabel) 
  self.freshVar = freshVar;
  self.freshLabel = freshLabel;
end
InsertGotos.__name__ = true
InsertGotos.prototype = _hx_e();
InsertGotos.prototype.insertFunc = function(self,f,breakLabel) 
  local args = f[2];
  local vararg = f[3];
  local body = f[4];
  local _g = self;
  local breakLabel = breakLabel;
  local f = function(stmt) 
    do return _g:insertStmt(stmt, breakLabel) end;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g_current = 0;
  local _g_array = body;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local x = _g_array[_g_current - 1];
    _g:push(f(x));
  end;
  local _g1 = _hx_tab_array({}, 0);
  local e = _g:iterator();
  while (e:hasNext()) do _hx_do_first_1 = false;
    
    local e = e:next();
    local x = e:iterator();
    while (x:hasNext()) do _hx_do_first_2 = false;
      
      local x = x:next();
      _g1:push(x);
    end;
  end;
  do return FunctionDef.FuncDef(args, vararg, _g1) end
end
InsertGotos.prototype.hasLastReturn = function(self,stmts) 
  if (stmts.length == 0) then 
    do return false end;
  end;
  local _g = stmts[stmts.length - 1];
  if (_g[1] == 9) then 
    local _g = _g[2];
    do return true end;
  else
    do return false end;
  end;
end
InsertGotos.prototype.insertExpr = function(self,expr,breakLabel) 
  if (expr[1] == 0) then 
    local f = expr[2];
    do return Expr.FunctionExpr(self:insertFunc(f, breakLabel)) end;
  else
    do return expr end;
  end;
end
InsertGotos.prototype.insertStmt = function(self,stmt,breakLabel) 
  local _g = self;
  local breakLabel1 = breakLabel;
  local _insertStmt = function(stmt) 
    do return _g:insertStmt(stmt, breakLabel1) end;
  end;
  local _g = self;
  local breakLabel1 = breakLabel;
  local _insertFunc = function(f) 
    do return _g:insertFunc(f, breakLabel1) end;
  end;
  local _g = self;
  local breakLabel1 = breakLabel;
  local _insertExpr = function(expr) 
    do return _g:insertExpr(expr, breakLabel1) end;
  end;
  local tmp = stmt[1];
  if (tmp) == 0 then 
    local cond = stmt[2];
    local thenBody = stmt[3];
    local elseBody = stmt[4];
    local endLabel = self.freshLabel:next();
    if (not self:hasLastReturn(thenBody)) then 
      thenBody:push(Stmt.GotoStatement(endLabel));
    end;
    if (not self:hasLastReturn(elseBody) and (elseBody.length > 0)) then 
      elseBody:push(Stmt.GotoStatement(endLabel));
    end;
    local tmp = _insertExpr(cond);
    local _g = _hx_tab_array({}, 0);
    local _g_current = 0;
    local _g_array = thenBody;
    while (_g_current < _g_array.length) do _hx_do_first_1 = false;
      
      _g_current = _g_current + 1;
      local x = _g_array[_g_current - 1];
      _g:push(_insertStmt(x));
    end;
    local _g1 = _hx_tab_array({}, 0);
    local e = _g:iterator();
    while (e:hasNext()) do _hx_do_first_1 = false;
      
      local e = e:next();
      local x = e:iterator();
      while (x:hasNext()) do _hx_do_first_2 = false;
        
        local x = x:next();
        _g1:push(x);
      end;
    end;
    local tmp1 = _g1;
    local _g = _hx_tab_array({}, 0);
    local _g_current = 0;
    local _g_array = elseBody;
    while (_g_current < _g_array.length) do _hx_do_first_1 = false;
      
      _g_current = _g_current + 1;
      local x = _g_array[_g_current - 1];
      _g:push(_insertStmt(x));
    end;
    local _g1 = _hx_tab_array({}, 0);
    local e = _g:iterator();
    while (e:hasNext()) do _hx_do_first_1 = false;
      
      local e = e:next();
      local x = e:iterator();
      while (x:hasNext()) do _hx_do_first_2 = false;
        
        local x = x:next();
        _g1:push(x);
      end;
    end;
    do return _hx_tab_array({[0]=Stmt.IfStatement(tmp, tmp1, _g1), Stmt.LabelStatement(endLabel)}, 2) end;
  elseif (tmp) == 1 then 
    local cond = stmt[2];
    local body = stmt[3];
    local whileLabel = self.freshLabel:next();
    local breakLabel = self.freshLabel:next();
    if (not self:hasLastReturn(body)) then 
      body:push(Stmt.GotoStatement(whileLabel));
    end;
    local tmp = Stmt.LabelStatement(whileLabel);
    local tmp1 = _insertExpr(cond);
    local _g = self;
    local breakLabel1 = __haxe_ds_Option.Some(breakLabel);
    local f = function(stmt) 
      do return _g:insertStmt(stmt, breakLabel1) end;
    end;
    local _g = _hx_tab_array({}, 0);
    local _g_current = 0;
    local _g_array = body;
    while (_g_current < _g_array.length) do _hx_do_first_1 = false;
      
      _g_current = _g_current + 1;
      local x = _g_array[_g_current - 1];
      _g:push(f(x));
    end;
    local _g1 = _hx_tab_array({}, 0);
    local e = _g:iterator();
    while (e:hasNext()) do _hx_do_first_1 = false;
      
      local e = e:next();
      local x = e:iterator();
      while (x:hasNext()) do _hx_do_first_2 = false;
        
        local x = x:next();
        _g1:push(x);
      end;
    end;
    do return _hx_tab_array({[0]=tmp, Stmt.IfStatement(tmp1, _g1, _hx_tab_array({}, 0)), Stmt.LabelStatement(breakLabel)}, 3) end;
  elseif (tmp) == 2 then 
    local body = stmt[2];
    local _g = _hx_tab_array({}, 0);
    local _g_current = 0;
    local _g_array = body;
    while (_g_current < _g_array.length) do _hx_do_first_1 = false;
      
      _g_current = _g_current + 1;
      local x = _g_array[_g_current - 1];
      _g:push(_insertStmt(x));
    end;
    local _g1 = _hx_tab_array({}, 0);
    local e = _g:iterator();
    while (e:hasNext()) do _hx_do_first_1 = false;
      
      local e = e:next();
      local x = e:iterator();
      while (x:hasNext()) do _hx_do_first_2 = false;
        
        local x = x:next();
        _g1:push(x);
      end;
    end;
    do return _hx_tab_array({[0]=Stmt.DoStatement(_g1)}, 1) end;
  elseif (tmp) == 3 then 
    local variable = stmt[2];
    local start = stmt[3];
    local finish = stmt[4];
    local step = stmt[5];
    local body = stmt[6];
    local forLabel = self.freshLabel:next();
    local breakLabel = self.freshLabel:next();
    local finishVar = self.freshVar:next();
    local stepVar = self.freshVar:next();
    local stepExpr;
    local stepExpr1 = step[1];
    if (stepExpr1) == 0 then 
      local step = step[2];
      stepExpr = step;
    elseif (stepExpr1) == 1 then 
      stepExpr = Expr.NumberExpr(1); end;
    body:push(Stmt.AssignmentStatement(_hx_tab_array({[0]=Expr.VarExpr(variable)}, 1), _hx_tab_array({[0]=Expr.BinopExpr(Expr.VarExpr(variable), "+", 0, stepExpr)}, 1)));
    if (not self:hasLastReturn(body)) then 
      body:push(Stmt.GotoStatement(forLabel));
    end;
    local tmp = Stmt.LocalStatement(_hx_tab_array({[0]=variable, finishVar, stepVar}, 3), _hx_tab_array({[0]=start, finish, stepExpr}, 3));
    local tmp1 = Stmt.LabelStatement(forLabel);
    local tmp2 = Expr.BinopExpr(Expr.VarExpr(variable), "<=", 0, Expr.VarExpr(finishVar));
    local _g = self;
    local breakLabel1 = __haxe_ds_Option.Some(breakLabel);
    local f = function(stmt) 
      do return _g:insertStmt(stmt, breakLabel1) end;
    end;
    local _g = _hx_tab_array({}, 0);
    local _g_current = 0;
    local _g_array = body;
    while (_g_current < _g_array.length) do _hx_do_first_1 = false;
      
      _g_current = _g_current + 1;
      local x = _g_array[_g_current - 1];
      _g:push(f(x));
    end;
    local _g1 = _hx_tab_array({}, 0);
    local e = _g:iterator();
    while (e:hasNext()) do _hx_do_first_1 = false;
      
      local e = e:next();
      local x = e:iterator();
      while (x:hasNext()) do _hx_do_first_2 = false;
        
        local x = x:next();
        _g1:push(x);
      end;
    end;
    do return _hx_tab_array({[0]=tmp, tmp1, Stmt.IfStatement(tmp2, _g1, _hx_tab_array({}, 0)), Stmt.LabelStatement(breakLabel)}, 4) end;
  elseif (tmp) == 4 then 
    local varList = stmt[2];
    local generators = stmt[3];
    local body = stmt[4];
    local forLabel = self.freshLabel:next();
    local breakLabel = self.freshLabel:next();
    local iterFunc = self.freshVar:next();
    local invState = self.freshVar:next();
    local ctrlVar = self.freshVar:next();
    if (not self:hasLastReturn(body)) then 
      body:push(Stmt.GotoStatement(forLabel));
    end;
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = generators;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(_insertExpr(i));
    end;
    local tmp = Stmt.LocalStatement(_hx_tab_array({[0]=iterFunc, invState, ctrlVar}, 3), _g);
    local tmp1 = Stmt.LabelStatement(forLabel);
    local tmp2 = Stmt.LocalStatement(varList, _hx_tab_array({[0]=Expr.CallExpr(Expr.VarExpr(iterFunc), _hx_tab_array({[0]=Expr.VarExpr(invState), Expr.VarExpr(ctrlVar)}, 2))}, 1));
    local tmp3 = Stmt.AssignmentStatement(_hx_tab_array({[0]=Expr.VarExpr(ctrlVar)}, 1), _hx_tab_array({[0]=Expr.VarExpr(varList[0])}, 1));
    local tmp4 = Expr.BinopExpr(Expr.VarExpr(ctrlVar), "==", 0, Expr.NilExpr);
    local _g = self;
    local breakLabel1 = __haxe_ds_Option.Some(breakLabel);
    local f = function(stmt) 
      do return _g:insertStmt(stmt, breakLabel1) end;
    end;
    local _g = _hx_tab_array({}, 0);
    local _g_current = 0;
    local _g_array = body;
    while (_g_current < _g_array.length) do _hx_do_first_1 = false;
      
      _g_current = _g_current + 1;
      local x = _g_array[_g_current - 1];
      _g:push(f(x));
    end;
    local _g1 = _hx_tab_array({}, 0);
    local e = _g:iterator();
    while (e:hasNext()) do _hx_do_first_1 = false;
      
      local e = e:next();
      local x = e:iterator();
      while (x:hasNext()) do _hx_do_first_2 = false;
        
        local x = x:next();
        _g1:push(x);
      end;
    end;
    do return _hx_tab_array({[0]=tmp, tmp1, tmp2, tmp3, Stmt.IfStatement(tmp4, _g1, _hx_tab_array({}, 0)), Stmt.LabelStatement(breakLabel)}, 6) end;
  elseif (tmp) == 5 then 
    local cond = stmt[2];
    local body = stmt[3];
    local repeatLabel = self.freshLabel:next();
    local breakLabel = self.freshLabel:next();
    if (not self:hasLastReturn(body)) then 
      body:push(Stmt.GotoStatement(repeatLabel));
    end;
    local tmp = Stmt.LabelStatement(repeatLabel);
    local _g = self;
    local breakLabel1 = __haxe_ds_Option.Some(breakLabel);
    local f = function(stmt) 
      do return _g:insertStmt(stmt, breakLabel1) end;
    end;
    local _g = _hx_tab_array({}, 0);
    local _g_current = 0;
    local _g_array = body;
    while (_g_current < _g_array.length) do _hx_do_first_1 = false;
      
      _g_current = _g_current + 1;
      local x = _g_array[_g_current - 1];
      _g:push(f(x));
    end;
    local _g1 = _hx_tab_array({}, 0);
    local e = _g:iterator();
    while (e:hasNext()) do _hx_do_first_1 = false;
      
      local e = e:next();
      local x = e:iterator();
      while (x:hasNext()) do _hx_do_first_2 = false;
        
        local x = x:next();
        _g1:push(x);
      end;
    end;
    do return _hx_tab_array({[0]=tmp, Stmt.DoStatement(_g1), Stmt.IfStatement(_insertExpr(cond), _hx_tab_array({[0]=Stmt.GotoStatement(repeatLabel)}, 1), _hx_tab_array({}, 0)), Stmt.LabelStatement(breakLabel)}, 4) end;
  elseif (tmp) == 6 then 
    local name = stmt[2];
    local isLocal = stmt[3];
    local f = stmt[4];
    do return _hx_tab_array({[0]=Stmt.FunctionStatement(name, isLocal, self:insertFunc(f, breakLabel))}, 1) end;
  elseif (tmp) == 7 then 
    local _g = stmt[2];
    local _g1 = stmt[3];
    if (_g.length == 1) then 
      if (_g1.length == 1) then 
        local _g2 = _g1[0];
        if (_g2[1] == 4) then 
          local base = _g2[2];
          local args = _g2[3];
          local name = _g[0];
          local label = self.freshLabel:next();
          local _g = _hx_tab_array({}, 0);
          local _g1 = 0;
          local _g2 = args;
          while (_g1 < _g2.length) do _hx_do_first_1 = false;
            
            local i = _g2[_g1];
            _g1 = _g1 + 1;
            _g:push(_insertExpr(i));
          end;
          do return _hx_tab_array({[0]=Stmt.LocalStatement(_hx_tab_array({[0]=name}, 1), _hx_tab_array({[0]=Expr.CallExpr(base, _g)}, 1)), Stmt.GotoStatement(label), Stmt.LabelStatement(label)}, 3) end;
        else
          local names = _g;
          local initExprs = _g1;
          local _g = _hx_tab_array({}, 0);
          local _g1 = 0;
          local _g2 = initExprs;
          while (_g1 < _g2.length) do _hx_do_first_1 = false;
            
            local i = _g2[_g1];
            _g1 = _g1 + 1;
            _g:push(_insertExpr(i));
          end;
          do return _hx_tab_array({[0]=Stmt.LocalStatement(names, _g)}, 1) end;
        end;
      else
        local names = _g;
        local initExprs = _g1;
        local _g = _hx_tab_array({}, 0);
        local _g1 = 0;
        local _g2 = initExprs;
        while (_g1 < _g2.length) do _hx_do_first_1 = false;
          
          local i = _g2[_g1];
          _g1 = _g1 + 1;
          _g:push(_insertExpr(i));
        end;
        do return _hx_tab_array({[0]=Stmt.LocalStatement(names, _g)}, 1) end;
      end;
    else
      local names = _g;
      local initExprs = _g1;
      local _g = _hx_tab_array({}, 0);
      local _g1 = 0;
      local _g2 = initExprs;
      while (_g1 < _g2.length) do _hx_do_first_1 = false;
        
        local i = _g2[_g1];
        _g1 = _g1 + 1;
        _g:push(_insertExpr(i));
      end;
      do return _hx_tab_array({[0]=Stmt.LocalStatement(names, _g)}, 1) end;
    end;
  elseif (tmp) == 8 then 
    local _g = stmt[2];
    do return _hx_tab_array({[0]=stmt}, 1) end;
  elseif (tmp) == 9 then 
    local args = stmt[2];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = args;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(_insertExpr(i));
    end;
    do return _hx_tab_array({[0]=Stmt.ReturnStatement(_g)}, 1) end;
  elseif (tmp) == 10 then 
    local tmp = breakLabel[1];
    if (tmp) == 0 then 
      local label = breakLabel[2];
      do return _hx_tab_array({[0]=Stmt.GotoStatement(label)}, 1) end;
    elseif (tmp) == 1 then 
      do return _hx_tab_array({}, 0) end; end;
  elseif (tmp) == 11 then 
    local _g = stmt[2];
    do return _hx_tab_array({[0]=stmt}, 1) end;
  elseif (tmp) == 12 then 
    local lhs = stmt[2];
    local rhs = stmt[3];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = lhs;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(_insertExpr(i));
    end;
    local tmp = _g;
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = rhs;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(_insertExpr(i));
    end;
    do return _hx_tab_array({[0]=Stmt.AssignmentStatement(tmp, _g)}, 1) end;
  elseif (tmp) == 13 then 
    local base = stmt[2];
    local args = stmt[3];
    local label = self.freshLabel:next();
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = args;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(_insertExpr(i));
    end;
    do return _hx_tab_array({[0]=Stmt.CallStatement(base, _g), Stmt.GotoStatement(label), Stmt.LabelStatement(label)}, 3) end; end;
end
InsertGotos.prototype.insertStmts = function(self,stmts) 
  local _g = self;
  local breakLabel = __haxe_ds_Option.None;
  local f = function(stmt) 
    do return _g:insertStmt(stmt, breakLabel) end;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g_current = 0;
  local _g_array = stmts;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local x = _g_array[_g_current - 1];
    _g:push(f(x));
  end;
  local _g1 = _hx_tab_array({}, 0);
  local e = _g:iterator();
  while (e:hasNext()) do _hx_do_first_1 = false;
    
    local e = e:next();
    local x = e:iterator();
    while (x:hasNext()) do _hx_do_first_2 = false;
      
      local x = x:next();
      _g1:push(x);
    end;
  end;
  do return _g1 end
end

InsertGotos.prototype.__class__ =  InsertGotos

LuaParse.new = {}
LuaParse.__name__ = true
LuaParse.tab = function(indent) 
  do return StringTools.rpad("", " ", indent * 4) end;
end
LuaParse.te2str = function(tableElem,indent) 
  local indent = indent;
  local e2str = function(expr) 
    do return LuaParse.e2str(expr, indent) end;
  end;
  local tmp = tableElem[1];
  if (tmp) == 0 then 
    local key = tableElem[2];
    local value = tableElem[3];
    do return Std.string(Std.string(Std.string("[") .. Std.string(e2str(key))) .. Std.string("] = ")) .. Std.string(e2str(value)) end;
  elseif (tmp) == 1 then 
    local key = tableElem[2];
    local value = tableElem[3];
    do return Std.string(Std.string(Std.string("") .. Std.string(key)) .. Std.string(" = ")) .. Std.string(e2str(value)) end;
  elseif (tmp) == 2 then 
    local value = tableElem[2];
    do return Std.string("") .. Std.string(e2str(value)) end; end;
end
LuaParse.e2str = function(expr,indent) 
  local indent1 = indent;
  local e2str = function(expr) 
    do return LuaParse.e2str(expr, indent1) end;
  end;
  local indent1 = indent;
  local f2str = function(f) 
    do return LuaParse.f2str(f, indent1) end;
  end;
  local indent1 = indent;
  local te2str = function(tableElem) 
    do return LuaParse.te2str(tableElem, indent1) end;
  end;
  local tmp = expr[1];
  if (tmp) == 0 then 
    local f = expr[2];
    do return Std.string(Std.string(Std.string(Std.string("function ") .. Std.string(f2str(f))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end") end;
  elseif (tmp) == 1 then 
    local name = expr[2];
    do return Std.string("") .. Std.string(name) end;
  elseif (tmp) == 2 then 
    local base = expr[2];
    local indexer = expr[3];
    local ident = expr[4];
    do return Std.string(Std.string(Std.string("") .. Std.string(e2str(base))) .. Std.string(indexer)) .. Std.string(ident) end;
  elseif (tmp) == 3 then 
    local base = expr[2];
    local index = expr[3];
    do return Std.string(Std.string(Std.string(Std.string("") .. Std.string(e2str(base))) .. Std.string("[")) .. Std.string(e2str(index))) .. Std.string("]") end;
  elseif (tmp) == 4 then 
    local base = expr[2];
    local args = expr[3];
    local tmp = Std.string(Std.string("") .. Std.string(e2str(base))) .. Std.string("(");
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = args;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(e2str(i));
    end;
    do return Std.string(Std.string(tmp) .. Std.string(_g:join(", "))) .. Std.string(")") end;
  elseif (tmp) == 5 then 
    local value = expr[2];
    do return Std.string("") .. Std.string(value) end;
  elseif (tmp) == 6 then 
    local value = expr[2];
    do return Std.string("") .. Std.string(value) end;
  elseif (tmp) == 7 then 
    do return "nil" end;
  elseif (tmp) == 8 then 
    local value = expr[2];
    if (value) then 
      do return "true" end;
    else
      do return "false" end;
    end;
  elseif (tmp) == 9 then 
    do return "..." end;
  elseif (tmp) == 10 then 
    local entryList = expr[2];
    if (entryList.length >= 5) then 
      local tmp = Std.string("{\n") .. Std.string(LuaParse.tab(indent + 1));
      local _g = _hx_tab_array({}, 0);
      local _g1 = 0;
      local _g2 = entryList;
      while (_g1 < _g2.length) do _hx_do_first_1 = false;
        
        local i = _g2[_g1];
        _g1 = _g1 + 1;
        _g:push(te2str(i));
      end;
      do return Std.string(Std.string(Std.string(Std.string(tmp) .. Std.string(_g:join(Std.string(",\n") .. Std.string(LuaParse.tab(indent + 1))))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("}") end;
    else
      local _g = _hx_tab_array({}, 0);
      local _g1 = 0;
      local _g2 = entryList;
      while (_g1 < _g2.length) do _hx_do_first_1 = false;
        
        local i = _g2[_g1];
        _g1 = _g1 + 1;
        _g:push(te2str(i));
      end;
      do return Std.string(Std.string("{") .. Std.string(_g:join(", "))) .. Std.string("}") end;
    end;
  elseif (tmp) == 11 then 
    local rhs = expr[2];
    local op = expr[3];
    local opPrec = expr[4];
    do return Std.string(Std.string(Std.string("") .. Std.string(op)) .. Std.string(" ")) .. Std.string(e2str(rhs)) end;
  elseif (tmp) == 12 then 
    local lhs = expr[2];
    local op = expr[3];
    local opPrec = expr[4];
    local rhs = expr[5];
    do return Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(e2str(lhs))) .. Std.string(" ")) .. Std.string(op)) .. Std.string(" ")) .. Std.string(e2str(rhs)) end; end;
end
LuaParse.sta2str = function(stmtArray,indent) 
  if (indent == nil) then 
    indent = -1;
  end;
  local indent = indent + 1;
  local st2str = function(stmt) 
    do return LuaParse.st2str(stmt, indent) end;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = stmtArray;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(st2str(i));
  end;
  do return _g:join("\n") end;
end
LuaParse.f2str = function(f,indent) 
  local indent = indent;
  local sta2str = function(stmtArray) 
    do return LuaParse.sta2str(stmtArray, indent) end;
  end;
  local args = f[2];
  local vararg = f[3];
  local body = f[4];
  if (vararg) then 
    args:push("...");
  end;
  do return Std.string(Std.string(Std.string("(") .. Std.string(args:join(", "))) .. Std.string(")\n")) .. Std.string(sta2str(body)) end;
end
LuaParse.st2str = function(stmt,indent) 
  local indent1 = indent;
  local e2str = function(expr) 
    do return LuaParse.e2str(expr, indent1) end;
  end;
  local indent1 = indent;
  local f2str = function(f) 
    do return LuaParse.f2str(f, indent1) end;
  end;
  local indent1 = indent;
  local st2str = function(stmt) 
    do return LuaParse.st2str(stmt, indent1) end;
  end;
  local indent1 = indent;
  local sta2str = function(stmtArray) 
    do return LuaParse.sta2str(stmtArray, indent1) end;
  end;
  local tmp = LuaParse.tab(indent);
  local tmp1;
  local tmp2 = stmt[1];
  if (tmp2) == 0 then 
    local _g = stmt[2];
    local _g1 = stmt[3];
    local _g2 = stmt[4];
    local _g3 = _g2.length;
    if (_g3) == 0 then 
      local thenBody = _g1;
      local cond = _g;
      tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("if ") .. Std.string(e2str(cond))) .. Std.string(" then\n")) .. Std.string(sta2str(thenBody))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end");
    elseif (_g3) == 1 then 
      local _g3 = _g2[0];
      if (_g3[1] == 0) then 
        local _g2 = _g3[2];
        local _g2 = _g3[3];
        local _g2 = _g3[4];
        local nextIf = _g3;
        local thenBody = _g1;
        local cond = _g;
        tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("if ") .. Std.string(e2str(cond))) .. Std.string(" then\n")) .. Std.string(sta2str(thenBody))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("else")) .. Std.string(StringTools.ltrim(st2str(nextIf)));
      else
        local elseBody = _g2;
        local thenBody = _g1;
        local cond = _g;
        tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("if ") .. Std.string(e2str(cond))) .. Std.string(" then\n")) .. Std.string(sta2str(thenBody))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("else\n")) .. Std.string(sta2str(elseBody))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end");
      end;else
    local elseBody = _g2;
    local thenBody = _g1;
    local cond = _g;
    tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("if ") .. Std.string(e2str(cond))) .. Std.string(" then\n")) .. Std.string(sta2str(thenBody))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("else\n")) .. Std.string(sta2str(elseBody))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end"); end;
  elseif (tmp2) == 1 then 
    local cond = stmt[2];
    local body = stmt[3];
    tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("while ") .. Std.string(e2str(cond))) .. Std.string(" do\n")) .. Std.string(sta2str(body))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end");
  elseif (tmp2) == 2 then 
    local body = stmt[2];
    tmp1 = Std.string(Std.string(Std.string(Std.string("do\n") .. Std.string(sta2str(body))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end");
  elseif (tmp2) == 3 then 
    local _g = stmt[2];
    local _g1 = stmt[3];
    local _g2 = stmt[4];
    local _g3 = stmt[5];
    local _g4 = stmt[6];
    local tmp = _g3[1];
    if (tmp) == 0 then 
      local step = _g3[2];
      local finish = _g2;
      local start = _g1;
      local variable = _g;
      local body = _g4;
      tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("for ") .. Std.string(variable)) .. Std.string(" = ")) .. Std.string(e2str(start))) .. Std.string(", ")) .. Std.string(e2str(finish))) .. Std.string(", ")) .. Std.string(e2str(step))) .. Std.string(" do\n")) .. Std.string(sta2str(body))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end");
    elseif (tmp) == 1 then 
      local finish = _g2;
      local start = _g1;
      local variable = _g;
      local body = _g4;
      tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("for ") .. Std.string(variable)) .. Std.string(" = ")) .. Std.string(e2str(start))) .. Std.string(", ")) .. Std.string(e2str(finish))) .. Std.string(" do\n")) .. Std.string(sta2str(body))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end"); end;
  elseif (tmp2) == 4 then 
    local varList = stmt[2];
    local generators = stmt[3];
    local body = stmt[4];
    local tmp = Std.string(Std.string("for ") .. Std.string(varList:join(", "))) .. Std.string(" in ");
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = generators;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(e2str(i));
    end;
    tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(tmp) .. Std.string(_g:join(", "))) .. Std.string(" do\n")) .. Std.string(sta2str(body))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end");
  elseif (tmp2) == 5 then 
    local cond = stmt[2];
    local body = stmt[3];
    tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string("repeat\n") .. Std.string(sta2str(body))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("until ")) .. Std.string(e2str(cond));
  elseif (tmp2) == 6 then 
    local name = stmt[2];
    local isLocal = stmt[3];
    local f = stmt[4];
    tmp1 = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(((function() 
      local _hx_1
      if (isLocal) then 
      _hx_1 = "local "; else 
      _hx_1 = ""; end
      return _hx_1
    end )()))) .. Std.string("function ")) .. Std.string(e2str(name))) .. Std.string(f2str(f))) .. Std.string("\n")) .. Std.string(LuaParse.tab(indent))) .. Std.string("end");
  elseif (tmp2) == 7 then 
    local _g = stmt[2];
    local _g1 = stmt[3];
    if (_g1.length == 0) then 
      local names = _g;
      tmp1 = Std.string("local ") .. Std.string(names:join(", "));
    else
      local initExprs = _g1;
      local names = _g;
      local tmp = Std.string(Std.string("local ") .. Std.string(names:join(", "))) .. Std.string(" = ");
      local _g = _hx_tab_array({}, 0);
      local _g1 = 0;
      local _g2 = initExprs;
      while (_g1 < _g2.length) do _hx_do_first_1 = false;
        
        local i = _g2[_g1];
        _g1 = _g1 + 1;
        _g:push(e2str(i));
      end;
      tmp1 = Std.string(tmp) .. Std.string(_g:join(", "));
    end;
  elseif (tmp2) == 8 then 
    local label = stmt[2];
    tmp1 = Std.string(Std.string("::") .. Std.string(label)) .. Std.string("::");
  elseif (tmp2) == 9 then 
    local args = stmt[2];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = args;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(e2str(i));
    end;
    tmp1 = Std.string("return ") .. Std.string(_g:join(", "));
  elseif (tmp2) == 10 then 
    tmp1 = "break";
  elseif (tmp2) == 11 then 
    local label = stmt[2];
    tmp1 = Std.string("goto ") .. Std.string(label);
  elseif (tmp2) == 12 then 
    local lhs = stmt[2];
    local rhs = stmt[3];
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = lhs;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(e2str(i));
    end;
    local tmp = Std.string(Std.string("") .. Std.string(_g:join(", "))) .. Std.string(" = ");
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = rhs;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(e2str(i));
    end;
    tmp1 = Std.string(tmp) .. Std.string(_g:join(", "));
  elseif (tmp2) == 13 then 
    local base = stmt[2];
    local args = stmt[3];
    local tmp = Std.string(Std.string("") .. Std.string(e2str(base))) .. Std.string("(");
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local _g2 = args;
    while (_g1 < _g2.length) do _hx_do_first_1 = false;
      
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(e2str(i));
    end;
    tmp1 = Std.string(Std.string(tmp) .. Std.string(_g:join(", "))) .. Std.string(")"); end;
  do return Std.string(tmp) .. Std.string(tmp1) end;
end
LuaParse.main = function() 
  Parser.Init(Array, __haxe_ds_Option, Stmt, Expr, TableElem, FunctionDef);
  local _g = __haxe_ds_StringMap.new();
  _g.h.disableEmitLeadingWhite = true;
  _g.h.disableEmitTokenList = true;
  local map = _g;
  local ret = ({});
  local k = map:keys();
  while (k:hasNext()) do _hx_do_first_1 = false;
    
    local k = k:next();
    local ret1 = map.h[k];
    ret[k] = (function() 
      local _hx_1
      if (ret1 == __haxe_ds_StringMap.tnull) then 
      _hx_1 = nil; else 
      _hx_1 = ret1; end
      return _hx_1
    end )();
  end;
  local options = ret;
  local data = __sys_io_File.getContent("ParseLua.lua");

  local computer
  local before
  if os.sleep then
    computer = require("computer")
    for i = 1, 10 do
      os.sleep(0)
    end
    before = computer.totalMemory() - computer.freeMemory()
  end

  local parsed = Parser.ParseLua(data, options);
  local varGenerator = NameGenerator.new("t");
  local labelGenerator = NameGenerator.new("l");
  local pullTransformer = PullFunction.new(varGenerator);
  local transformed = pullTransformer:pullStmts(parsed);
  local gotoTransformer = InsertGotos.new(varGenerator, labelGenerator);
  local gotosInserted = gotoTransformer:insertStmts(transformed);

  if os.sleep then
    local peak = 0
    for i = 1, 10 do
      peak = math.max(peak, computer.totalMemory() - computer.freeMemory())
      os.sleep(0)
    end
    local after = computer.totalMemory() - computer.freeMemory()
    print(#transformed, #parsed, #gotosInserted)
    print(string.format("Memory before: %d\nMemory after: %d\nDifference: %d\nPeak: %d\n", before // 1024, after // 1024, (after - before) // 1024, peak // 1024))
  end
  -- print(inspect(parsed))

  -- _G.io.write(Std.string(LuaParse.sta2str(gotosInserted)));
--   _G.io.flush();
end

Math.new = {}
Math.__name__ = true
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

OrderedStringMapImpl.new = function() 
  local self = _hx_new(OrderedStringMapImpl.prototype)
  OrderedStringMapImpl.super(self)
  return self
end
OrderedStringMapImpl.super = function(self) 
  self._innerMap = __haxe_ds_StringMap.new();
  self._orderedKeys = _hx_tab_array({}, 0);
end
OrderedStringMapImpl.__name__ = true
OrderedStringMapImpl.__interfaces__ = {IOrderedMap}
OrderedStringMapImpl.prototype = _hx_e();
OrderedStringMapImpl.prototype.set = function(self,key,value) 
  if (self._innerMap.h[key] == nil) then 
    self._orderedKeys:push(key);
  end;
  local _this = self._innerMap;
  if (value == nil) then 
    _this.h[key] = __haxe_ds_StringMap.tnull;
  else
    _this.h[key] = value;
  end;
end
OrderedStringMapImpl.prototype.get = function(self,key) 
  local ret = self._innerMap.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    do return nil end;
  else
    do return ret end;
  end;
end
OrderedStringMapImpl.prototype.keys = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self._orderedKeys) end
end
OrderedStringMapImpl.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end

OrderedStringMapImpl.prototype.__class__ =  OrderedStringMapImpl

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "function") and not ((function() 
        local _hx_2
        if (_G.type(o) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = o.__name__; end
        return _hx_2
      end )() or (function() 
        local _hx_3
        if (_G.type(o) ~= "table") then 
        _hx_3 = false; else 
        _hx_3 = o.__ename__; end
        return _hx_3
      end )())) then 
      _hx_1 = false; elseif ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.indexOfEmpty = function(s,startIndex) 
  local length = _G.string.len(s);
  if (startIndex < 0) then 
    startIndex = length + startIndex;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
  end;
  if (startIndex > length) then 
    do return length end;
  else
    do return startIndex end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_e();
String.prototype.toUpperCase = function(self) 
  do return _G.string.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return _G.string.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  if (str == "") then 
    do return String.indexOfEmpty(self, startIndex - 1) end;
  end;
  local r = _G.string.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = #self;
  end;
  while (true) do _hx_do_first_1 = false;
    
    local p = String.prototype.indexOf(self, str, ret + 1);
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do _hx_do_first_1 = false;
    
    local newidx = 0;
    if (#delimiter > 0) then 
      newidx = _G.string.find(self, delimiter, idx, true);
    else
      if (idx >= #self) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = _G.string.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + #delimiter;
    else
      ret:push(_G.string.sub(self, idx, #self));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = #self;
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return _G.string.sub(self, endIndex + 1, startIndex) end;
  else
    do return _G.string.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return _G.string.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return _G.string.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + #self))) then 
    len = #self;
  else
    if (len < 0) then 
      len = #self + len;
    end;
  end;
  if (pos < 0) then 
    pos = #self + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return _G.string.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return _hx_tostring(s, 0) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end

StringTools.new = {}
StringTools.__name__ = true
StringTools.isSpace = function(s,pos) 
  if (((#s == 0) or (pos < 0)) or (pos >= #s)) then 
    do return false end;
  end;
  local c = _G.string.byte(s, pos + 1);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = #s;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, r)) do _hx_do_first_1 = false;
    
    r = r + 1;
  end;
  if (r > 0) then 
    do return String.prototype.substr(s, r, l - r) end;
  else
    do return s end;
  end;
end
StringTools.rpad = function(s,c,l) 
  if (#c <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  local str = Std.string(s);
  _G.table.insert(buf_b, str);
  buf_length = buf_length + #str;
  while (buf_length < l) do _hx_do_first_1 = false;
    
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + #str;
  end;
  do return _G.table.concat(buf_b) end;
end

__haxe_Exception.new = function(message,previous,native) 
  local self = _hx_new(__haxe_Exception.prototype)
  __haxe_Exception.super(self,message,previous,native)
  return self
end
__haxe_Exception.super = function(self,message,previous,native) 
  self.__skipStack = 0;
  self.__exceptionMessage = message;
  self.__previousException = previous;
  if (native ~= nil) then 
    self.__nativeException = native;
    self.__nativeStack = __haxe_NativeStackTrace.exceptionStack();
  else
    self.__nativeException = self;
    self.__nativeStack = __haxe_NativeStackTrace.callStack();
    self.__skipStack = 1;
  end;
end
__haxe_Exception.__name__ = true
__haxe_Exception.thrown = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value:get_native() end;
  else
    local e = __haxe_ValueException.new(value);
    e.__skipStack = e.__skipStack + 1;
    do return e end;
  end;
end
__haxe_Exception.prototype = _hx_e();
__haxe_Exception.prototype.toString = function(self) 
  do return self:get_message() end
end
__haxe_Exception.prototype.get_message = function(self) 
  do return self.__exceptionMessage end
end
__haxe_Exception.prototype.get_native = function(self) 
  do return self.__nativeException end
end

__haxe_Exception.prototype.__class__ =  __haxe_Exception

__haxe_NativeStackTrace.new = {}
__haxe_NativeStackTrace.__name__ = true
__haxe_NativeStackTrace.saveStack = function(exception) 
end
__haxe_NativeStackTrace.callStack = function() 
  local _g = debug.traceback();
  if (_g == nil) then 
    do return _hx_tab_array({}, 0) end;
  else
    local s = _g;
    do return String.prototype.split(s, "\n"):slice(3) end;
  end;
end
__haxe_NativeStackTrace.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end

__haxe_ValueException.new = function(value,previous,native) 
  local self = _hx_new(__haxe_ValueException.prototype)
  __haxe_ValueException.super(self,value,previous,native)
  return self
end
__haxe_ValueException.super = function(self,value,previous,native) 
  __haxe_Exception.super(self,(function() 
    local _hx_1
    if (value == nil) then 
    _hx_1 = "null"; else 
    _hx_1 = Std.string(value); end
    return _hx_1
  end )(),previous,native);
  self.value = value;
end
__haxe_ValueException.__name__ = true
__haxe_ValueException.prototype = _hx_e();

__haxe_ValueException.prototype.__class__ =  __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype,{__index=__haxe_Exception.prototype})
_hxClasses["haxe.ds.Option"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Some","None"},2)}
__haxe_ds_Option = _hxClasses["haxe.ds.Option"];
__haxe_ds_Option.Some = function(v) local _x = _hx_tab_array2({[0]="Some",0,v}, 3); return _x; end 
__haxe_ds_Option.None = _hx_tab_array2({[0]="None",1},2)


__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_StringMap.__name__ = true
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_e();
__haxe_ds_StringMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    do return nil end;
  end;
  do return ret end
end
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__haxe_exceptions_PosException.new = function(message,previous,pos) 
  local self = _hx_new(__haxe_exceptions_PosException.prototype)
  __haxe_exceptions_PosException.super(self,message,previous,pos)
  return self
end
__haxe_exceptions_PosException.super = function(self,message,previous,pos) 
  __haxe_Exception.super(self,message,previous);
  if (pos == nil) then 
    self.posInfos = _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="(unknown)",lineNumber=0,className="(unknown)",methodName="(unknown)"});
  else
    self.posInfos = pos;
  end;
end
__haxe_exceptions_PosException.__name__ = true
__haxe_exceptions_PosException.prototype = _hx_e();
__haxe_exceptions_PosException.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(__haxe_Exception.prototype.toString(self))) .. Std.string(" in ")) .. Std.string(self.posInfos.className)) .. Std.string(".")) .. Std.string(self.posInfos.methodName)) .. Std.string(" at ")) .. Std.string(self.posInfos.fileName)) .. Std.string(":")) .. Std.string(self.posInfos.lineNumber) end
end

__haxe_exceptions_PosException.prototype.__class__ =  __haxe_exceptions_PosException
__haxe_exceptions_PosException.__super__ = __haxe_Exception
setmetatable(__haxe_exceptions_PosException.prototype,{__index=__haxe_Exception.prototype})

__haxe_exceptions_NotImplementedException.new = function(message,previous,pos) 
  local self = _hx_new(__haxe_exceptions_NotImplementedException.prototype)
  __haxe_exceptions_NotImplementedException.super(self,message,previous,pos)
  return self
end
__haxe_exceptions_NotImplementedException.super = function(self,message,previous,pos) 
  if (message == nil) then 
    message = "Not implemented";
  end;
  __haxe_exceptions_PosException.super(self,message,previous,pos);
end
__haxe_exceptions_NotImplementedException.__name__ = true
__haxe_exceptions_NotImplementedException.prototype = _hx_e();

__haxe_exceptions_NotImplementedException.prototype.__class__ =  __haxe_exceptions_NotImplementedException
__haxe_exceptions_NotImplementedException.__super__ = __haxe_exceptions_PosException
setmetatable(__haxe_exceptions_NotImplementedException.prototype,{__index=__haxe_exceptions_PosException.prototype})

__haxe_iterators_ArrayIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
  __haxe_iterators_ArrayIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
__haxe_iterators_ArrayIterator.__name__ = true
__haxe_iterators_ArrayIterator.prototype = _hx_e();
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self) 
  do return self.array[(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end

__haxe_iterators_ArrayIterator.prototype.__class__ =  __haxe_iterators_ArrayIterator

__haxe_iterators_ArrayKeyValueIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
  __haxe_iterators_ArrayKeyValueIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self,array) 
  self.array = array;
end
__haxe_iterators_ArrayKeyValueIterator.__name__ = true
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e();

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ =  __haxe_iterators_ArrayKeyValueIterator

__haxe_iterators_MapKeyValueIterator.new = function(map) 
  local self = _hx_new(__haxe_iterators_MapKeyValueIterator.prototype)
  __haxe_iterators_MapKeyValueIterator.super(self,map)
  return self
end
__haxe_iterators_MapKeyValueIterator.super = function(self,map) 
  self.map = map;
  self.keys = map:keys();
end
__haxe_iterators_MapKeyValueIterator.__name__ = true
__haxe_iterators_MapKeyValueIterator.prototype = _hx_e();
__haxe_iterators_MapKeyValueIterator.prototype.hasNext = function(self) 
  do return self.keys:hasNext() end
end
__haxe_iterators_MapKeyValueIterator.prototype.next = function(self) 
  local key = self.keys:next();
  do return _hx_o({__fields__={value=true,key=true},value=self.map:get(key),key=key}) end
end

__haxe_iterators_MapKeyValueIterator.prototype.__class__ =  __haxe_iterators_MapKeyValueIterator

__lua_Boot.new = {}
__lua_Boot.__name__ = true
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl ~= nil) then 
          _hx_1 = cl; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do _hx_do_first_1 = false;
          
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end

__lua_UserData.new = {}
__lua_UserData.__name__ = true

__lua_Thread.new = {}
__lua_Thread.__name__ = true

__sys_io_File.new = {}
__sys_io_File.__name__ = true
__sys_io_File.getContent = function(path) 
  local f = _G.io.open(path, "r");
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string("Invalid path : ") .. Std.string(path)),0);
  end;
  local s = f:read("*all");
  f:close();
  do return s end;
end
if _hx_bit_raw then
    _hx_bit_clamp = function(v)
    if v <= 2147483647 and v >= -2147483648 then
        if v > 0 then return _G.math.floor(v)
        else return _G.math.ceil(v)
        end
    end
    if v > 2251798999999999 then v = v*2 end;
    if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
    return _hx_bit_raw.band(v, 2147483647 ) - math.abs(_hx_bit_raw.band(v, 2147483648))
    end
else
    _hx_bit_clamp = function(v)
        if v < -2147483648 then
            return -2147483648
        elseif v > 2147483647 then
            return 2147483647
        elseif v > 0 then
            return _G.math.floor(v)
        else
            return _G.math.ceil(v)
        end
    end
end;



_hx_array_mt.__index = Array.prototype

if package.loaded.luv then
  _hx_luv = _G.require("luv");
else
  _hx_luv = {
    run=function(mode) return false end,
    loop_alive=function() return false end
  }
end
local _hx_static_init = function()
  
  String.__name__ = true;
  Array.__name__ = true;__haxe_ds_StringMap.tnull = ({});
  
  
end

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

function _hx_handle_error(obj)
  local message = tostring(obj)
  if _G.debug and _G.debug.traceback then
    -- level 2 to skip _hx_handle_error
    message = _G.debug.traceback(message, 2)
  end
  return setmetatable({}, { __tostring = function() return message end })
end

_hx_static_init();
local success, err = _G.xpcall(function() 
  LuaParse.main();
  _hx_luv.run();
end, _hx_handle_error)
if not success then _G.error(err) end
